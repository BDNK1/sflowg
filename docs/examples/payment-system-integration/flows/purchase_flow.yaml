id: purchase_flow

# Simplified comprehensive flow testing all SFlowG features
# Focus: Readability and feature coverage without excessive complexity

entrypoint:
  type: http
  config:
    method: post
    path: /api/purchase/:orderId
    headers:
      - Authorization
      - X-Request-ID
    pathVariables:
      - orderId
    queryParameters:
      - currency
      - notify
    body:
      type: json

properties:
  # Service URLs
  paymentProviderURL: "http://localhost:9002/v1/charges"
  notificationServiceURL: "http://localhost:9000/notify"

  # Business rules
  taxRate: 0.15
  shippingCost: 9.99
  freeShippingThreshold: 100.00

  # Limits
  minOrderAmount: 5.00
  maxOrderAmount: 10000.00

steps:
  # ========================================
  # STEP 1: Generate Transaction ID
  # Tests: Plugin task invocation
  # ========================================
  - id: generateTxnId
    type: uuidgen.generateUUID
    args: {}

  # ========================================
  # STEP 2: Extract Request Data
  # Tests: Variable resolution, nested access, expressions, ternary
  # ========================================
  - id: extractData
    type: assign
    args:
      # Request variable resolution
      orderId: request.pathVariables.orderId
      requestId: request.headers.X-Request-ID
      authToken: request.headers.Authorization

      # Nested field access
      itemPrice: request.body.item.price
      quantity: request.body.item.quantity
      customerEmail: request.body.customer.email

      # Ternary expressions with defaults
      currency: 'request.queryParameters.currency != "" ? request.queryParameters.currency : "USD"'
      shouldNotify: 'request.queryParameters.notify == "true"'

      # Property access
      txnId: generateTxnId.result.uuid

  # ========================================
  # STEP 3: Calculate Totals
  # Tests: Arithmetic, complex expressions, ternary for business rules
  # ========================================
  - id: calculateTotals
    type: assign
    args:
      # Arithmetic expressions
      subtotal: extractData.itemPrice * extractData.quantity

      # Ternary for shipping logic
      shipping: 'extractData.itemPrice * extractData.quantity >= properties.freeShippingThreshold ? 0.0 : properties.shippingCost'

      # Tax calculation
      tax: extractData.itemPrice * extractData.quantity * properties.taxRate

      # Final total with complex expression
      total: 'extractData.itemPrice * extractData.quantity + (extractData.itemPrice * extractData.quantity >= properties.freeShippingThreshold ? 0.0 : properties.shippingCost) + (extractData.itemPrice * extractData.quantity * properties.taxRate)'

  # ========================================
  # STEP 4: Validate Amount and Route Flow
  # Tests: Switch step, comparisons, logical operators
  # ========================================
  - id: routeFlow
    type: switch
    args:
      invalidAmount: >
        calculateTotals.total < properties.minOrderAmount ||
        calculateTotals.total > properties.maxOrderAmount
      validateCard: >
        calculateTotals.total >= properties.minOrderAmount &&
        calculateTotals.total <= properties.maxOrderAmount

  # ========================================
  # Branch: Invalid Amount
  # ========================================
  - id: invalidAmount
    type: assign
    args:
      status: '"amount_invalid"'
      statusCode: 400
      message: >
        calculateTotals.total < properties.minOrderAmount ?
          "Order amount below minimum" :
          "Order amount exceeds maximum"

  # ========================================
  # Branch: Process Payment
  # Tests: Typed plugin task, conditional execution
  # ========================================
  - id: validateCard
    type: payment.validateCard
    args:
      card_number: request.body.payment.card.number
      expiry_date: request.body.payment.card.expiry
      cvv: request.body.payment.card.cvv

  # ========================================
  # STEP 5: Process Payment with Retry
  # Tests: Plugin task with retry, backoff, retry condition
  # ========================================
  - id: processPayment
    type: payment.processPayment
    condition: validateCard.result.valid == true
    args:
      amount: calculateTotals.total
      currency: extractData.currency
      card_number: request.body.payment.card.number
      expiry_date: request.body.payment.card.expiry
      cvv: request.body.payment.card.cvv
      description: '"Purchase order " + extractData.orderId'
      customer_email: extractData.customerEmail
    retry:
      maxRetries: 3
      delay: 1000
      backoff: true
      condition: processPayment.result.status != "completed"

  # ========================================
  # STEP 6: Call Payment Provider API
  # Tests: HTTP request, headers, body, retry with condition
  # ========================================
  - id: callProviderAPI
    type: http.request
    condition: processPayment.result.success == true
    args:
      url: properties.paymentProviderURL
      method: post
      headers:
        Authorization: extractData.authToken
        Content-Type: '"application/json"'
        X-Transaction-ID: extractData.txnId
      body:
        transaction_id: extractData.txnId
        amount: calculateTotals.total
        currency: extractData.currency
        authorization_code: processPayment.result.authorization_code
    retry:
      maxRetries: 3
      delay: 500
      backoff: true
      condition: callProviderAPI.result.statusCode >= 500

  # ========================================
  # STEP 7: Determine Success Status
  # Tests: Assign with conditional expressions
  # ========================================
  - id: determineStatus
    type: assign
    args:
      finalStatus: >
        (validateCard.result == null || validateCard.result.valid == false) ? "card_invalid" :
        (processPayment.result == null || processPayment.result.success == false) ? "payment_failed" :
        (callProviderAPI.result != null && callProviderAPI.result.statusCode == 200) ? "success" :
        "provider_error"

      statusCode: >
        (validateCard.result == null || validateCard.result.valid == false) ? 400 :
        (processPayment.result == null || processPayment.result.success == false) ? 402 :
        (callProviderAPI.result != null && callProviderAPI.result.statusCode == 200) ? 200 :
        502

      statusMessage: >
        (validateCard.result == null || validateCard.result.valid == false) ? "Card validation failed" :
        (processPayment.result == null || processPayment.result.success == false) ? (processPayment.result != null ? processPayment.result.message : "Payment processing failed") :
        (callProviderAPI.result != null && callProviderAPI.result.statusCode == 200) ? "Payment processed successfully" :
        "Payment provider error"

  # ========================================
  # STEP 8: Send Notification
  # Tests: HTTP request with complex condition, query parameters
  # ========================================
  - id: sendNotification
    type: http.request
    condition: >
      extractData.shouldNotify == true &&
      determineStatus.finalStatus == "success"
    args:
      url: properties.notificationServiceURL
      method: post
      headers:
        Content-Type: '"application/json"'
      body:
        customer_email: extractData.customerEmail
        order_id: extractData.orderId
        transaction_id: extractData.txnId
        amount: calculateTotals.total
        currency: extractData.currency

  # ========================================
  # STEP 9: Get Plugin Statistics
  # Tests: Untyped plugin task (map-based)
  # ========================================
  - id: getStats
    type: payment.getStatus
    args: {}

  # ========================================
  # STEP 10: Build Response
  # Tests: Complex nested structures, string concatenation
  # ========================================
  - id: buildResponse
    type: assign
    args:
      responseBody:
        success: determineStatus.finalStatus == "success"
        status: determineStatus.finalStatus
        message: determineStatus.statusMessage
        data:
          order:
            id: extractData.orderId
            transactionId: extractData.txnId
          pricing:
            subtotal: calculateTotals.subtotal
            shipping: calculateTotals.shipping
            tax: calculateTotals.tax
            total: calculateTotals.total
            currency: extractData.currency
          payment:
            cardType: 'validateCard.result.card_type != null ? validateCard.result.card_type : "unknown"'
            lastFourDigits: 'validateCard.result.last_four_digits != null ? validateCard.result.last_four_digits : ""'
            authorizationCode: 'processPayment.result.authorization_code != null ? processPayment.result.authorization_code : ""'
          metadata:
            requestId: extractData.requestId
            notificationSent: sendNotification.result != null && sendNotification.result.statusCode == 200
            pluginStats: getStats.result

# ========================================
# RETURN: HTTP Response
# Tests: Response construction, dynamic status, headers
# ========================================
return:
  type: http.response
  args:
    status: determineStatus.statusCode
    headers:
      X-Transaction-ID: extractData.txnId
      X-Request-ID: extractData.requestId
    body: buildResponse.responseBody
