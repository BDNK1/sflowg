// Cancel an order

entrypoint.http {
    method: POST
    path: /api/orders/:id/cancel
    pathVariables: [id]
}

step fetch_order {
    postgres.get({
        query: "SELECT id, status FROM orders WHERE id = $1",
        params: [request.pathVariables.id]
    })
}

step not_found(condition: fetch_order.found == false) {
    response.json({
        status: 404,
        body: { error: "order not found" }
    })
}

step already_canceled(condition: fetch_order.row.status == "canceled") {
    response.json({
        status: 409,
        body: { error: "order is already canceled" }
    })
}

step already_paid(condition: fetch_order.row.status == "paid") {
    response.json({
        status: 409,
        body: { error: "paid order cannot be canceled" }
    })
}

step mark_canceled {
    let result = postgres.get({
        query: "UPDATE orders SET status = 'canceled', canceled_at = NOW(), paid_at = NULL WHERE id = $1 RETURNING id, customer_email, customer_name, amount_cents, currency, status, stripe_payment_id, stripe_payment_intent_id, stripe_client_secret, created_at, paid_at, canceled_at",
        params: [request.pathVariables.id]
    })
    if (result.found == false) {
        raise("CANCEL_FAILED", "order could not be marked as canceled")
    }
    result
}

return response.json({
    status: 200,
    body: {
        order: mark_canceled.row
    }
})

on_error {
    if (error.type == "timeout") {
        response.json({
            status: 504,
            body: { error: "request timed out while canceling order" }
        })
    } else if (error.code == "CANCEL_FAILED") {
        response.json({
            status: 500,
            body: { error: "failed to cancel order", details: error.message }
        })
    } else {
        response.json({
            status: 500,
            body: { error: "unexpected error", details: error.message }
        })
    }
}
