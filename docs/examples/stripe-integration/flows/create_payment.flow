entrypoint.http {
    method: POST
    path: /api/payments
    headers: [X-Request-ID]
    body: { type: json }
    timeout: 15000
}

step extract_request {
    {
        amount: request.body.amount,
        currency: request.body.currency ?? properties.default_currency,
        description: request.body.description ?? "Payment",
        customer_email: request.body.customer_email?.to_lower()?.trim_space(),
        customer_name: request.body.customer_name,
        metadata_order_id: request.body.metadata?.order_id,
        request_id: request.headers["X-Request-ID"]
    }
}

step validate_order_id(condition: extract_request.metadata_order_id == nil || extract_request.metadata_order_id == "") {
    response.json({
        status: 400,
        body: {
            success: false,
            error: {
                code: "ORDER_ID_REQUIRED",
                message: "metadata.order_id is required"
            }
        }
    })
}

step insert_payment {
    postgres.get({
        query: "INSERT INTO payments (amount, currency, description, customer_email, customer_name, metadata_order_id, status, created_at) VALUES ($1, $2, $3, $4, $5, $6, $7, NOW()) RETURNING id, created_at",
        params: [
            extract_request.amount,
            extract_request.currency,
            extract_request.description,
            extract_request.customer_email,
            extract_request.customer_name,
            extract_request.metadata_order_id,
            "pending"
        ]
    })
} compensate {
    postgres.exec({
        query: "DELETE FROM payments WHERE id = $1 AND status = 'pending'",
        params: [insert_payment.row.id]
    })
}

step store_payment_id {
    {
        payment_id: insert_payment.row.id,
        created_at: insert_payment.row.created_at
    }
}

step create_payment_intent(retry: { max_attempts: 3, delay: 500, backoff: "exponential" }) {
    let result = http.request({
        url: properties.stripe_api_url + "/payment_intents",
        method: "POST",
        content_type: "form",
        headers: {
            Authorization: "Bearer " + properties.stripe_secret_key
        },
        body: {
            amount: extract_request.amount,
            currency: extract_request.currency,
            description: extract_request.description,
            receipt_email: extract_request.customer_email,
            metadata: {
                payment_id: store_payment_id.payment_id,
                order_id: extract_request.metadata_order_id
            }
        }
    })
    if (result.status_code >= 500) {
        raise("transient", "STRIPE_SERVICE_ERROR", "Stripe API temporarily unavailable")
    }
    if (result.status_code != 200) {
        let code = result.body?.error?.type ?? "STRIPE_ERROR"
        let message = result.body?.error?.message ?? "Stripe API error"
        raise(code, message)
    }
    result
}

step update_payment_success {
    postgres.exec({
        query: "UPDATE payments SET stripe_payment_intent_id = $1, stripe_client_secret = $2, stripe_status = $3, status = $4, updated_at = NOW() WHERE id = $5",
        params: [
            create_payment_intent.body.id,
            create_payment_intent.body.client_secret,
            create_payment_intent.body.status,
            "requires_payment_method",
            store_payment_id.payment_id
        ]
    })
}

return response.json({
    status: 201,
    headers: {
        "X-Order-ID": sprintf("%v", extract_request.metadata_order_id)
    },
    body: {
        success: true,
        data: {
            order_id: extract_request.metadata_order_id,
            client_secret: create_payment_intent.body.client_secret,
            payment_intent_id: create_payment_intent.body.id,
            status: create_payment_intent.body.status,
            amount: extract_request.amount,
            currency: extract_request.currency,
            checkout_url: properties.public_base_url + "/checkout/order/" + sprintf("%v", extract_request.metadata_order_id)
        }
    }
})

on_error {
    postgres.exec({
        query: "UPDATE payments SET status = 'failed', error_message = $1, updated_at = NOW() WHERE status = 'pending'",
        params: [error.message]
    })

    let error_response = match error.type {
        "timeout" => {
            status: 504,
            code: "TIMEOUT",
            message: "payment creation timed out"
        }
        "transient" => {
            status: 503,
            code: error.code,
            message: error.message
        }
        _ => {
            status: 400,
            code: error.code,
            message: error.message
        }
    }

    response.json({
        status: error_response.status,
        body: {
            success: false,
            error: {
                code: error_response.code,
                message: error_response.message
            }
        }
    })
}
